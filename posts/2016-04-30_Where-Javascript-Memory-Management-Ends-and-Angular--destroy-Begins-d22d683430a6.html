<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Where Javascript Memory Management Ends and Angular $destroy Begins</title>
  <style>
    * {
      font-family: Georgia, Cambria, "Times New Roman", Times, serif;
    }

    html, body {
      margin: 0;
      padding: 0;
    }

    h1 {
      font-size: 50px;
      margin-bottom: 17px;
      color: #333;
    }

    h2 {
      font-size: 24px;
      line-height: 1.6;
      margin: 30px 0 0 0;
      margin-bottom: 18px;
      margin-top: 33px;
      color: #333;
    }

    h3 {
      font-size: 30px;
      margin: 10px 0 20px 0;
      color: #333;
    }

    header {
      width: 640px;
      margin: auto;
    }

    section {
      width: 640px;
      margin: auto;
    }

    section p {
      margin-bottom: 27px;
      font-size: 20px;
      line-height: 1.6;
      color: #333;
    }

    section img {
      max-width: 640px;
    }

    footer {
      padding: 0 20px;
      margin: 50px 0;
      text-align: center;
      font-size: 12px;
    }

    .aspectRatioPlaceholder {
      max-width: auto !important;
      max-height: auto !important;
    }

    .aspectRatioPlaceholder-fill {
      padding-bottom: 0 !important;
    }

    header,
    section[data-field=subtitle],
    section[data-field=description] {
      display: none;
    }
  </style>
</head>
<body>
<article class="h-entry">
  <header>
    <h1 class="p-name">Where Javascript Memory Management Ends and Angular $destroy Begins</h1>
  </header>
  <section data-field="subtitle" class="p-summary">
    A brief look inside the source code (inspired by this SO question)
  </section>
  <section data-field="body" class="e-content">
    <section name="f2ea" class="section section--body section--first">
      <div class="section-divider">
        <hr class="section-divider">
      </div>
      <div class="section-content">
        <div class="section-inner sectionLayout--fullWidth">
          <figure name="3fde" id="3fde" class="graf graf--figure graf--layoutFillWidth graf--leading">
            <div class="aspectRatioPlaceholder is-locked">
              <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.5%;"></div>
              <img class="graf-image" data-image-id="1*pNvM6iCGGdT0mXaohO3Fdg.jpeg" data-width="3008" data-height="2000"
                   src="https://cdn-images-1.medium.com/max/2560/1*pNvM6iCGGdT0mXaohO3Fdg.jpeg"></div>
          </figure>
        </div>
        <div class="section-inner sectionLayout--insetColumn"><h3 name="6bf6" id="6bf6"
                                                                  class="graf graf--h3 graf-after--figure graf--title">
          Where Javascript Memory Management Ends and Angular $destroy Begins</h3><h4 name="a48c" id="a48c"
                                                                                      class="graf graf--h4 graf-after--h3 graf--subtitle">
          A brief look inside the source code (<em class="markup--em markup--h4-em">inspired by this </em><a
            href="http://stackoverflow.com/questions/36273862/do-i-need-to-destroy-local-controller-variables-when-directive-is-destroyed/36390832#36390832"
            data-href="http://stackoverflow.com/questions/36273862/do-i-need-to-destroy-local-controller-variables-when-directive-is-destroyed/36390832#36390832"
            class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank"><em
            class="markup--em markup--h4-em">SO question</em></a><em class="markup--em markup--h4-em">)</em></h4>
          <p name="f5e0" id="f5e0" class="graf graf--p graf-after--h4">Keep this example controller function in
            mind:</p>
          <figure name="8055" id="8055" class="graf graf--figure graf--iframe graf-after--p graf--trailing"></figure>
        </div>
      </div>
    </section>
    <section name="d854" class="section section--body">
      <div class="section-divider">
        <hr class="section-divider">
      </div>
      <div class="section-content">
        <div class="section-inner sectionLayout--insetColumn"><h4 name="4d02" id="4d02"
                                                                  class="graf graf--h4 graf--leading">Javascript memory
          management — garbage collector</h4>
          <p name="4b48" id="4b48" class="graf graf--p graf-after--h4">Memory <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management"
              data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management"
              class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">will be allocated for an object
            when created</a>.</p>
          <figure name="a255" id="a255" class="graf graf--figure graf--iframe graf-after--p"></figure>
          <p name="4de2" id="4de2" class="graf graf--p graf-after--figure">You may then <em
              class="markup--em markup--p-em">console.log(o.iThink)</em> and <em class="markup--em markup--p-em">‘thereforeIAm’ </em>will
            be read from its place in memory and printed to the console.</p>
          <p name="7efb" id="7efb" class="graf graf--p graf-after--p">If you wanted to create a new string and lost the
            <em class="markup--em markup--p-em">need</em> for the <em class="markup--em markup--p-em">{iThink:
              ‘thereforeIAm’}</em> object, you may decide to overwrite <em class="markup--em markup--p-em">o</em>
            instead of introducing a new variable.</p>
          <figure name="f7d3" id="f7d3" class="graf graf--figure graf--iframe graf-after--p"></figure>
          <p name="75aa" id="75aa" class="graf graf--p graf-after--figure">Fortunately, references (or lack thereof)
            send a clear message internally to javascript’s garbage collector as to whether a piece of finite memory
            should remain allocated or freed to perform other tasks. In this case, no reference remains to the object
            and string previously allocated for <em class="markup--em markup--p-em">{iThink: ‘thereforeIAm’}</em> and
            the corresponding memory may be freed (i.e. “garbage-collected”) as result.</p>
          <p name="e08b" id="e08b" class="graf graf--p graf-after--p graf--trailing">Importantly, note that garbage
            collection happens internally. No code has to be written by you to that effect. All you need to concern
            yourself with is the value of <em class="markup--em markup--p-em">o</em> and the garbage collector can <em
                class="markup--em markup--p-em">infer need</em>, more or less, <em class="markup--em markup--p-em">from
              remaining reference</em>.</p></div>
      </div>
    </section>
    <section name="eed6" class="section section--body">
      <div class="section-divider">
        <hr class="section-divider">
      </div>
      <div class="section-content">
        <div class="section-inner sectionLayout--insetColumn"><h4 name="cd2e" id="cd2e"
                                                                  class="graf graf--h4 graf--leading">Angular memory
          management — $scope.$destroy</h4>
          <p name="a46e" id="a46e" class="graf graf--p graf-after--h4">Unfortunately, the cleanup tasks related to <em
              class="markup--em markup--p-em">$scope</em> removal<em class="markup--em markup--p-em"> cannot be
            inferred</em> by the javascript garbage collector based on<em class="markup--em markup--p-em"> reference
            alone</em>; additional code is required.</p>
          <p name="4763" id="4763" class="graf graf--p graf-after--p">That is because <em
              class="markup--em markup--p-em">$scope</em> objects embody a concept more complex than any ol’ javascript
            object. In particular, when no use remains in your application for a certain <em
                class="markup--em markup--p-em">$scope</em> object, no use <em class="markup--em markup--p-em">must also
              remain </em>for any associated <em class="markup--em markup--p-em">$$watchers</em> previously registered
            with the <em class="markup--em markup--p-em">$scope.$watch</em> method and no use <em
                class="markup--em markup--p-em">must also remain</em> for “children” <em
                class="markup--em markup--p-em">$scope</em> objects. The javascript garbage collector cannot infer this
            relationship from simple reference removal. Setting <em class="markup--em markup--p-em">$scope</em> to <em
                class="markup--em markup--p-em">null </em>will certainly clear the memory allocated directly for such
            object, but not much else can be accomplished.</p>
          <figure name="06f0" id="06f0" class="graf graf--figure graf--iframe graf-after--p"></figure>
          <p name="1d85" id="1d85" class="graf graf--p graf-after--figure">In other words, the garbage collector has to
            be told what to do (<a
                href="https://github.com/angular/angular.js/blob/v1.5.5/src/ng/directive/ngIf.js#L113"
                data-href="https://github.com/angular/angular.js/blob/v1.5.5/src/ng/directive/ngIf.js#L113"
                class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">and when to do it</a>), which is
            exactly what the <a href="https://github.com/angular/angular.js/blob/v1.5.3/src/ng/rootScope.js#L895"
                                data-href="https://github.com/angular/angular.js/blob/v1.5.3/src/ng/rootScope.js#L895"
                                class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em
                class="markup--em markup--p-em">$scope.$destroy</em> method</a> does. Note these lines in particular:
          </p>
          <figure name="6585" id="6585" class="graf graf--figure graf--iframe graf-after--p graf--trailing"></figure>
        </div>
      </div>
    </section>
    <section name="ce42" class="section section--body section--last">
      <div class="section-divider">
        <hr class="section-divider">
      </div>
      <div class="section-content">
        <div class="section-inner sectionLayout--insetColumn"><h4 name="ef41" id="ef41"
                                                                  class="graf graf--h4 graf--leading">The example
          controller function</h4>
          <p name="f60f" id="f60f" class="graf graf--p graf-after--h4">When a function is invoked, the memory allocated
            for internally scoped objects will only remain allocated to the extent references remain past the life of
            the invocation (non-coincidentally, the essence of a closure).</p>
          <p name="c3f8" id="c3f8" class="graf graf--p graf-after--p">In the example of the controller, <em
              class="markup--em markup--p-em">uploader</em> and <em class="markup--em markup--p-em">reader</em> objects
            are created and <em class="markup--em markup--p-em">uploader</em> is set to scope. No references remain to
            <em class="markup--em markup--p-em">reader</em> at all after the controller function is run, rendering <em
                class="markup--em markup--p-em">reader</em> eligible for garbage collection immediately thereafter. On
            the other hand, <em class="markup--em markup--p-em">uploader</em> is attached to an object that outlives the
            function’s invocation and so must remain an occupant of allocated memory until such object is destroyed. As
            a result, only a call to <em class="markup--em markup--p-em">$scope.$destroy</em> would enable the
            reallocation of memory once allocated to <em class="markup--em markup--p-em">uploader </em>as the lack of
            need cannot be inferred from reference alone.</p>
          <p name="4464" id="4464" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Quote
            of the day:</strong></p>
          <blockquote name="66fe" id="66fe" class="graf graf--blockquote graf-after--p">Each product era can be divided
            into two phases: 1) <em class="markup--em markup--blockquote-em">the gestation phase</em>, when the new
            platform is first introduced but is expensive, incomplete, and/or difficult to use, 2) <em
                class="markup--em markup--blockquote-em">the growth phase</em>, when a new product comes along that
            solves those problems, kicking off a period of exponential growth. The Apple II was released in 1977 (and
            the Altair in 1975), but it was the release of the IBM PC in 1981 that kicked off the PC growth phase. The
            internet’s gestation phase took place in the <a
                href="https://en.wikipedia.org/wiki/National_Science_Foundation_Network"
                data-href="https://en.wikipedia.org/wiki/National_Science_Foundation_Network"
                class="markup--anchor markup--blockquote-anchor" rel="nofollow noopener" target="_blank">80s and early
              90s</a> when it was mostly a text-based tool used by academia and government. The release of the Mosaic
            web browser in 1993 started the growth phase, which has continued ever since.There were feature phones in
            the 90s and early smartphones like the Sidekick and Blackberry in the early 2000s, but the smartphone growth
            phase really started in 2007–8 with the release of the iPhone and then Android.
          </blockquote>
          <blockquote name="6de7" id="6de7" class="graf graf--blockquote graf-after--blockquote graf--trailing">— <a
              href="https://medium.com/software-is-eating-the-world/what-s-next-in-computing-e54b870b80cc#.jszig85hi"
              data-href="https://medium.com/software-is-eating-the-world/what-s-next-in-computing-e54b870b80cc#.jszig85hi"
              class="markup--anchor markup--blockquote-anchor" target="_blank">Chris Dixon</a></blockquote>
        </div>
      </div>
    </section>
  </section>
  <footer>
    <p>By <a href="https://medium.com/@jbmilgrom" class="p-author h-card">Jonathan Milgrom</a> on <a
        href="https://medium.com/p/d22d683430a6">
      <time class="dt-published" datetime="2016-04-30T19:30:39.061Z">April 30, 2016</time>
    </a>.
    </p>
    <p><a
        href="https://medium.com/@jbmilgrom/where-javascript-memory-management-ends-and-angulars-destroy-begins-d22d683430a6"
        class="p-canonical">Canonical link</a></p>
    <p>Exported from <a href="https://medium.com">Medium</a> on May 2, 2020.</p></footer>
</article>
</body>
</html>