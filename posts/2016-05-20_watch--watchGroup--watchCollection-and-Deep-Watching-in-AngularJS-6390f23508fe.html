<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>watch, watchGroup, watchCollection and Deep Watching in AngularJS</title>
  <style>
    * {
      font-family: Georgia, Cambria, "Times New Roman", Times, serif;
    }

    html, body {
      margin: 0;
      padding: 0;
    }

    h1 {
      font-size: 50px;
      margin-bottom: 17px;
      color: #333;
    }

    h2 {
      font-size: 24px;
      line-height: 1.6;
      margin: 30px 0 0 0;
      margin-bottom: 18px;
      margin-top: 33px;
      color: #333;
    }

    h3 {
      font-size: 30px;
      margin: 10px 0 20px 0;
      color: #333;
    }

    header {
      width: 640px;
      margin: auto;
    }

    section {
      width: 640px;
      margin: auto;
    }

    section p {
      margin-bottom: 27px;
      font-size: 20px;
      line-height: 1.6;
      color: #333;
    }

    section img {
      max-width: 640px;
    }

    footer {
      padding: 0 20px;
      margin: 50px 0;
      text-align: center;
      font-size: 12px;
    }

    .aspectRatioPlaceholder {
      max-width: auto !important;
      max-height: auto !important;
    }

    .aspectRatioPlaceholder-fill {
      padding-bottom: 0 !important;
    }

    header,
    section[data-field=subtitle],
    section[data-field=description] {
      display: none;
    }
  </style>
</head>
<body>
<article class="h-entry">
  <header>
    <h1 class="p-name">watch, watchGroup, watchCollection and Deep Watching in AngularJS</h1>
  </header>
  <section data-field="subtitle" class="p-summary">
    The Many Layers of Change Detection in Angular 1.x
  </section>
  <section data-field="body" class="e-content">
    <section name="017b" class="section section--body section--first">
      <div class="section-divider">
        <hr class="section-divider">
      </div>
      <div class="section-content">
        <div class="section-inner sectionLayout--fullWidth">
          <figure name="688c" id="688c" class="graf graf--figure graf--layoutFillWidth graf--leading">
            <div class="aspectRatioPlaceholder is-locked">
              <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.7%;"></div>
              <img class="graf-image" data-image-id="1*ol3us_IBiS6O3qi4VWYu9Q.jpeg" data-width="1920" data-height="1280"
                   src="https://cdn-images-1.medium.com/max/2560/1*ol3us_IBiS6O3qi4VWYu9Q.jpeg"></div>
          </figure>
        </div>
        <div class="section-inner sectionLayout--insetColumn"><h3 name="2626" id="2626"
                                                                  class="graf graf--h3 graf-after--figure graf--title">
          watch, watchGroup, watchCollection and Deep Watching in AngularJS</h3><h4 name="f7b7" id="f7b7"
                                                                                    class="graf graf--h4 graf-after--h3 graf--subtitle">
          The Many Layers of Change Detection in Angular 1.x</h4>
          <p name="cbd4" id="cbd4" class="graf graf--p graf-after--h4">A user clicks the “upvote” button,</p>
          <figure name="7b57" id="7b57" class="graf graf--figure graf-after--p">
            <div class="aspectRatioPlaceholder is-locked" style="max-width: 52px; max-height: 146px;">
              <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 280.79999999999995%;"></div>
              <img class="graf-image" data-image-id="1*kU6Q7pi0coovXxIOy8UaEw.png" data-width="52" data-height="146"
                   src="https://cdn-images-1.medium.com/max/800/1*kU6Q7pi0coovXxIOy8UaEw.png"></div>
          </figure>
          <p name="1d1a" id="1d1a" class="graf graf--p graf-after--figure">attempting to increase the vote count to
            1034. An action <em class="markup--em markup--p-em">$apply</em><strong
                class="markup--strong markup--p-strong">’</strong>ed through an <em class="markup--em markup--p-em">ng-click</em>
          </p>
          <figure name="0cce" id="0cce" class="graf graf--figure graf--iframe graf-after--p"></figure>
          <p name="33da" id="33da" class="graf graf--p graf-after--figure">would trigger a <em
              class="markup--em markup--p-em">$digest</em> cycle under the hood, which checks all registered <em
              class="markup--em markup--p-em">$watch</em>’es for changes. Then, an expression providing “voted” styling
            for answers<em class="markup--em markup--p-em">, </em>registered through <em
                class="markup--em markup--p-em">ng-class</em></p>
          <figure name="a7d9" id="a7d9" class="graf graf--figure graf--iframe graf-after--p"></figure>
          <p name="ed51" id="ed51" class="graf graf--p graf-after--figure">and an expression providing the aggregate
            number of votes, registered through double curly braces <em class="markup--em markup--p-em">{{}}</em></p>
          <figure name="4c53" id="4c53" class="graf graf--figure graf--iframe graf-after--p"></figure>
          <p name="f347" id="f347" class="graf graf--p graf-after--figure">would trigger the appropriate DOM
            updates:</p>
          <figure name="545a" id="545a" class="graf graf--figure graf-after--p">
            <div class="aspectRatioPlaceholder is-locked" style="max-width: 60px; max-height: 142px;">
              <div class="aspectRatioPlaceholder-fill" style="padding-bottom: 236.7%;"></div>
              <img class="graf-image" data-image-id="1*CxheOXIunYTXze80R08l5A.png" data-width="60" data-height="142"
                   src="https://cdn-images-1.medium.com/max/800/1*CxheOXIunYTXze80R08l5A.png"></div>
          </figure>
          <p name="1d67" id="1d67"
             class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf-after--figure graf--trailing"><span
              class="graf-dropCap">C</span>hange detection is a fundamental part of AngularJS applications. Whether
            utilizing native AngularJS directives or building your own, an understanding of the many layers of data
            watching is essential to understanding Angular.</p></div>
      </div>
    </section>
    <section name="8024" class="section section--body">
      <div class="section-divider">
        <hr class="section-divider">
      </div>
      <div class="section-content">
        <div class="section-inner sectionLayout--insetColumn"><h3 name="517d" id="517d"
                                                                  class="graf graf--h3 graf--leading"><strong
            class="markup--strong markup--h3-strong">Some I</strong>nteresting (but skippable)<strong
            class="markup--strong markup--h3-strong"> background</strong></h3><h4 name="ec19" id="ec19"
                                                                                  class="graf graf--h4 graf-after--h3">
          An angular expression can produce different values over time.</h4>
          <p name="e643" id="e643" class="graf graf--p graf-after--h4">Watching consists of getting the value of an
            expression and performing a task when it has changed. In angular, an expression can take the form of a
            string or a javascript function:</p>
          <p name="8a46" id="8a46" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">1. any ol’
            javascript function</em></p>
          <figure name="9204" id="9204" class="graf graf--figure graf--iframe graf-after--p"></figure>
          <p name="c46d" id="c46d" class="graf graf--p graf-after--figure"><em class="markup--em markup--p-em">2.
            string</em></p>
          <figure name="ada2" id="ada2" class="graf graf--figure graf--iframe graf-after--p"></figure>
          <p name="722d" id="722d" class="graf graf--p graf-after--figure"><strong
              class="markup--strong markup--p-strong">Function or… string?</strong> Internally, the first thing the <em
              class="markup--em markup--p-em">$scope.$watch</em> method does is <a
              href="https://github.com/angular/angular.js/blob/v1.5.3/src/ng/rootScope.js#L387"
              data-href="https://github.com/angular/angular.js/blob/v1.5.3/src/ng/rootScope.js#L387"
              class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">pass its first parameter to the
            $parse service</a>. The <em class="markup--em markup--p-em">$parse</em> service is a function (obviously)
            that returns another function (let’s call it the “parseFn”). The <em
                class="markup--em markup--p-em">parseFn</em> expects to be called with the desired context object
            against which the original string or function may be evaluated e.g.</p>
          <figure name="7f98" id="7f98" class="graf graf--figure graf--iframe graf-after--p"></figure>
          <p name="a19c" id="a19c" class="graf graf--p graf-after--figure">If the <em class="markup--em markup--p-em">$parse</em>
            service receives a string, <a href="https://github.com/angular/angular.js/blob/v1.5.3/src/ng/parse.js#L1791"
                                          data-href="https://github.com/angular/angular.js/blob/v1.5.3/src/ng/parse.js#L1791"
                                          class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">work
              needs to be performed</a> in order to translate the string into proper javascript that is capable of
            evaluation against an object i.e. a function. On the other hand, if it receives a function, well… <a
                href="https://github.com/angular/angular.js/blob/v1.5.3/src/ng/parse.js#L1822"
                data-href="https://github.com/angular/angular.js/blob/v1.5.3/src/ng/parse.js#L1822"
                class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">not much needs to happen</a>.
            Since the service has received what it must produce, it may assume the function has been properly prepared.
            As you can see, most of the angular “magic” lies in parsing the string parameter into such a function to
            enable the intake of a string.</p>
          <p name="7395" id="7395" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">At
            any point in time</strong>. There is a reason angular has chosen the function-with-context-object-parameter
            structure: <em class="markup--em markup--p-em">c</em>alls to the function reveal changes to underlying
            context, which means that the function can be invoked at any point in time to retrieve the value of the
            underlying expression or function <em class="markup--em markup--p-em">at such time</em>:</p>
          <figure name="c254" id="c254" class="graf graf--figure graf--iframe graf-after--p">
            <figcaption class="imageCaption">A changing context — $parse’s bread and butter</figcaption>
          </figure>
          <p name="475a" id="475a" class="graf graf--p graf-after--figure">Since scope objects are…objects, this of
            course works with scope objects as well. The string <em class="markup--em markup--p-em">‘vm.answer.isVotedFor(vm.user)’ </em>from
            the “upvote” example above — after being passed to <em class="markup--em markup--p-em">parse </em>by <em
                class="markup--em markup--p-em">watch</em> and transformed into a function that is ready to accept an
            object — was ready to reveal any new <em class="markup--em markup--p-em">isVotedFor </em>status reflected in
            an updated scope object. Now the function-returning-a-function structure of the parse service also begins to
            make sense. The returned function (i.e the <em class="markup--em markup--p-em">parseFn</em>), prepped and
            ready to accept the latest scope object, is exactly what the digest cycle needs and <a
                href="https://github.com/angular/angular.js/blob/v1.5.3/src/ng/rootScope.js#L413"
                data-href="https://github.com/angular/angular.js/blob/v1.5.3/src/ng/rootScope.js#L413"
                class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">precisely what it receives</a> in
            order to get the latest value of an expression. Sensibly, the <em
                class="markup--em markup--p-em">parseFn</em> is <a
                href="https://github.com/angular/angular.js/blob/v1.5.3/src/ng/rootScope.js#L387"
                data-href="https://github.com/angular/angular.js/blob/v1.5.3/src/ng/rootScope.js#L387"
                class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">named “get” internally</a>
            because of these getter qualities.</p>
          <p name="68cc" id="68cc" class="graf graf--p graf-after--p graf--trailing"><strong
              class="markup--strong markup--p-strong">Against the last cached value</strong>. Now to determine change,
            all the <em class="markup--em markup--p-em">$digest</em> cycle has left to do is cache the <em
                class="markup--em markup--p-em">last</em> value retrieved by the registered <em
                class="markup--em markup--p-em">parseFn</em> and compare it to the next….which brings us to the topic of
            this post: this comparison between new and old values, what constitutes equality and the multiple levels of
            change detection in angular.</p></div>
      </div>
    </section>
    <section name="0475" class="section section--body">
      <div class="section-divider">
        <hr class="section-divider">
      </div>
      <div class="section-content">
        <div class="section-inner sectionLayout--insetColumn"><h3 name="9d2e" id="9d2e"
                                                                  class="graf graf--h3 graf--leading">
          $watch — type 1</h3>
          <p name="1da5" id="1da5" class="graf graf--p graf-after--h3">The simplest and most common, this type of <em
              class="markup--em markup--p-em">watch</em> uses javascript’s <em
              class="markup--em markup--p-em">===</em><strong class="markup--strong markup--p-strong"><em
              class="markup--em markup--p-em"> </em></strong>operator to compare old and new values, invoking the
            callback only upon <em class="markup--em markup--p-em">strict inequality</em>:</p>
          <figure name="099c" id="099c" class="graf graf--figure graf--iframe graf-after--p">
            <figcaption class="imageCaption">simple <strong class="markup--strong markup--figure-strong">watch</strong>
            </figcaption>
          </figure>
          <p name="5a21" id="5a21" class="graf graf--p graf-after--figure">For expressions that evaluate to primitive
            types like Strings and Numbers, this has a predictable effect. Old and new values of <em
                class="markup--em markup--p-em">4</em> and <em class="markup--em markup--p-em">4</em> are considered
            equal, but<em class="markup--em markup--p-em"> 4 </em>and <em class="markup--em markup--p-em">5</em> and<em
                class="markup--em markup--p-em"> 4</em> and <em class="markup--em markup--p-em">‘4’ </em>are not.
            Similarly, <em class="markup--em markup--p-em">‘hello’</em> and <em
                class="markup--em markup--p-em">‘hello’</em> will not register a change, but <em
                class="markup--em markup--p-em">‘hello’</em> and <em class="markup--em markup--p-em">‘goodbye’</em>
            will. In the above “upvote” example, angular’s curly brackets <em class="markup--em markup--p-em">{{}}</em>
            registered <a href="https://github.com/angular/angular.js/blob/master/src/ng/compile.js#L2782"
                          data-href="https://github.com/angular/angular.js/blob/master/src/ng/compile.js#L2782"
                          class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em
                class="markup--em markup--p-em">this</em> type of watch</a> for the expression <em
                class="markup--em markup--p-em">vm.answer.voteCount()</em>. When <em class="markup--em markup--p-em">1034</em>
            was compared against <em class="markup--em markup--p-em">1033</em>, a change was registered.</p>
          <p name="067e" id="067e" class="graf graf--p graf-after--p">For expressions that evaluate to javascript<em
              class="markup--em markup--p-em"> objects</em>, strict equality means something less intuitive. The same
            object, no matter how mutated between equality checks, will <em class="markup--em markup--p-em">not</em>
            register “change”, whereas, two different objects, no matter how similar, will:</p>
          <figure name="4dca" id="4dca" class="graf graf--figure graf--iframe graf-after--p">
            <figcaption class="imageCaption">Advantages and limitations of <strong
                class="markup--strong markup--figure-strong">watch</strong></figcaption>
          </figure>
          <p name="539b" id="539b" class="graf graf--p graf-after--figure">The important thing to note in determining
            how change is registered is not whether two objects have the same properties but whether two objects refer
            to the same address in memory i.e whether they are the same object. Notice in the above example that
            different objects with exactly the same properties and values nevertheless register change and print to the
            console with the latest object because they are different objects. Whereas, the same object reference prints
            nothing to the console no matter how mutated between equality checks.</p>
          <h3 name="702c" id="702c" class="graf graf--h3 graf-after--p">$watchGroup — type 2</h3>
          <p name="4f05" id="4f05" class="graf graf--p graf-after--h3">This type of watch can handle multiple
            expressions instead of being limited to just one, invoking the registered callback when <em
                class="markup--em markup--p-em">any</em> of the expressions have changed.</p>
          <figure name="a310" id="a310" class="graf graf--figure graf--iframe graf-after--p"></figure>
          <p name="3424" id="3424" class="graf graf--p graf-after--figure">You may want to use this type of watch if two
            or more properties are coupled. In the above “upvote” example, you could use this watch to disable further
            voting if an answer has been voted for <em class="markup--em markup--p-em">or</em> against:</p>
          <figure name="27f3" id="27f3" class="graf graf--figure graf--iframe graf-after--p">
            <figcaption class="imageCaption">Use-case for <strong class="markup--strong markup--figure-strong">watchGroup</strong>
            </figcaption>
          </figure>
          <p name="8194" id="8194" class="graf graf--p graf-after--figure">The important thing to note is that the
            containing array itself is <em class="markup--em markup--p-em">not</em> watched by <em
                class="markup--em markup--p-em">watchGroup, </em>in stark contrast to (maybe the more familiar) <em
                class="markup--em markup--p-em">watchCollection; </em>rather<em class="markup--em markup--p-em">, </em>each
            member of the array is. Much like the subject of a regular type 1 <em
                class="markup--em markup--p-em">watch</em>, each member of the array can itself be a string expression
            capable of contextual evaluation or a function ready to be passed a context object. As a result, <em
                class="markup--em markup--p-em">watchGroup</em> can be seen as simply a way to group together multiple
            regular type 1 <em class="markup--em markup--p-em">watch’</em>es with a single callback function. When <em
                class="markup--em markup--p-em">any of the grouped </em>watches registers a change, the callback is
            invoked. This set up has the benefit of allowing expressions to be members of the group as described. But
            members of the group cannot be dynamically added or subtracted and order is not an applicable concept…which
            brings us to <em class="markup--em markup--p-em">watchCollection</em>.</p>
          <h3 name="7ef3" id="7ef3" class="graf graf--h3 graf-after--p">$watchCollection — type 3</h3>
          <p name="5e5c" id="5e5c" class="graf graf--p graf-after--h3">This type of watch is intended for javascript
            arrays, invoking the callback when collection level changes have occurred.</p>
          <figure name="1eb2" id="1eb2" class="graf graf--figure graf--iframe graf-after--p">
            <figcaption class="imageCaption">Advantages and limitations of <strong
                class="markup--strong markup--figure-strong">watchCollection</strong></figcaption>
          </figure>
          <p name="7a01" id="7a01" class="graf graf--p graf-after--figure">Where <em class="markup--em markup--p-em">watchGroup</em>
            allows multiple expressions capable of contextual evaluation to point to one callback, <em
                class="markup--em markup--p-em">watchCollection</em> allows only one — in the above example, <em
                class="markup--em markup--p-em">‘firstTeam’</em>. On the other hand, the type of watch applied to such
            expression is more involved. Type 1 watchers care only about addresses for objects and values for
            primitives. As objects themselves, arrays are no different. Subject to a type 1 watch, expressions that
            evaluate to an array will not register change no matter how mutated between checks until switched out for an
            entirely new array and address in memory. <em class="markup--em markup--p-em">watchCollection</em> is vastly
            different. Mutation is the name of the game. In particular, <em class="markup--em markup--p-em">watchCollection</em>
            keeps its eye on two types of surface level array mutations: (1) addition/subtraction and (2) reordering.
            Adding or subtracting members of the array and reordering members of the array result in change being
            recognized and the registered callback being invoked. watchCollection only stops short of watching
            below-surface mutation i.e. deep mutation, mutations to the members themselves… which brings us to deep
            watching.</p>
          <h3 name="2e94" id="2e94" class="graf graf--h3 graf-after--p">$watch(…, …, true) — type 4</h3>
          <p name="2db0" id="2db0" class="graf graf--p graf-after--h3">The most expensive watch, this type of watch is
            also the most thorough, recursively scaling the depths of any complex object and invoking the registered
            callback when any branch of the tree has undergone change. Note the <em
                class="markup--em markup--p-em">true</em> flag, which tells angular to perform this type of watch
            instead of a type 1:</p>
          <figure name="2be5" id="2be5" class="graf graf--figure graf--iframe graf-after--p">
            <figcaption class="imageCaption"><strong class="markup--strong markup--figure-strong">watch(…, …,
              true)</strong> has no limitations
            </figcaption>
          </figure>
          <p name="bd54" id="bd54" class="graf graf--p graf-after--figure graf--trailing">Deep watching has no
            limitations, other than performance of course — the last thing your application needs is recursive journeys
            into the depths of complex objects <em class="markup--em markup--p-em">every</em> digest cycle. On the other
            hand, deep watching can keep any complex data in sync with the view and, as a result, may be the easiest to
            understand: all change is change.</p></div>
      </div>
    </section>
    <section name="80d7" class="section section--body section--last">
      <div class="section-divider">
        <hr class="section-divider">
      </div>
      <div class="section-content">
        <div class="section-inner sectionLayout--insetColumn"><p name="0669" id="0669"
                                                                 class="graf graf--p graf--leading">This has been a
          discussion of the many layers of data watching in AngularJS. I hope it helps inform your choice among
          them!</p>
          <p name="ede6" id="ede6" class="graf graf--p graf-after--p">Quote of the Day:</p>
          <blockquote name="ed71" id="ed71" class="graf graf--blockquote graf-after--p">Reporter: Why do you shoot so
            many 3&#39;s?
          </blockquote>
          <blockquote name="d4af" id="d4af" class="graf graf--blockquote graf-after--blockquote graf--trailing"><a
              href="http://espn.go.com/blog/truehoop/post/_/id/22316/behold-the-4-pointer"
              data-href="http://espn.go.com/blog/truehoop/post/_/id/22316/behold-the-4-pointer"
              class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">Antoine Walker</a>:
            Because there aren’t any 4&#39;s.
          </blockquote>
        </div>
      </div>
    </section>
  </section>
  <footer>
    <p>By <a href="https://medium.com/@jbmilgrom" class="p-author h-card">Jonathan Milgrom</a> on <a
        href="https://medium.com/p/6390f23508fe">
      <time class="dt-published" datetime="2016-05-20T12:37:59.925Z">May 20, 2016</time>
    </a>.
    </p>
    <p><a
        href="https://medium.com/@jbmilgrom/watch-watchgroup-watchcollection-and-deep-watching-in-angularjs-6390f23508fe"
        class="p-canonical">Canonical link</a></p>
    <p>Exported from <a href="https://medium.com">Medium</a> on May 2, 2020.</p></footer>
</article>
</body>
</html>